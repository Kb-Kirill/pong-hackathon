This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/
  game.py
  hand_tracker.py
  physics.py
  test_physics.py
.gitignore
README.md
requirements.txt
test_camera.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/test_physics.py">
import unittest
import math
from physics import BallPhysics

class TestBallPhysics(unittest.TestCase):
    def setUp(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –æ–±—ä–µ–∫—Ç–∞ —Ñ–∏–∑–∏–∫–∏ –ø–µ—Ä–µ–¥ –∫–∞–∂–¥—ã–º —Ç–µ—Å—Ç–æ–º"""
        self.ball = BallPhysics(table_width=800, table_height=600, net_height=50)
    
    def print_ball_status(self, label=""):
        """–í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ –¥–ª—è –≤—ã–≤–æ–¥–∞ —Å—Ç–∞—Ç—É—Å–∞ –º—è—á–∞"""
        x, y, z = self.ball.get_position()
        print(f"{label}: Pos=({x:.1f}, {y:.1f}, {z:.1f}) | Velocity=({self.ball.vx:.1f}, {self.ball.vy:.1f}, {self.ball.vz:.1f})")

    def test_initial_state(self):
        """–¢–µ—Å—Ç –Ω–∞—á–∞–ª—å–Ω–æ–≥–æ –ø–æ–ª–æ–∂–µ–Ω–∏—è –º—è—á–∞"""
        x, y, z = self.ball.get_position()
        self.assertAlmostEqual(x, 400, delta=0.1)
        self.assertAlmostEqual(y, 550, delta=0.1)
        self.assertEqual(z, 0)
        print("\nTest 1 - Initial Position:")
        self.print_ball_status("Start")

    def test_gravity_effect(self):
        """–¢–µ—Å—Ç –≤–ª–∏—è–Ω–∏—è –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏–∏ –Ω–∞ –º—è—á"""
        print("\nTest 2 - Gravity Effect:")
        self.ball.reset_ball()
        self.ball.vx, self.ball.vy, self.ball.vz = 0, 0, 5  # –ó–∞–¥–∞—ë–º –Ω–∞—á–∞–ª—å–Ω—É—é –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—É—é —Å–∫–æ—Ä–æ—Å—Ç—å
        
        for step in range(5):
            self.ball.update(0.1)
            self.print_ball_status(f"Step {step+1}")
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ Z-–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞ —É–º–µ–Ω—å—à–∞–µ—Ç—Å—è –ø–æ–¥ –¥–µ–π—Å—Ç–≤–∏–µ–º –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏–∏
        self.assertLess(self.ball.vz, 5)
        self.assertLess(self.ball.z, 5 * 0.1 * 5)  # z = v0*t - (g*t¬≤)/2

    # –í–∞—Ä–∏–∞–Ω—Ç 1 - –¢–µ—Å—Ç–∏—Ä—É–µ–º –±–∞–∑–æ–≤—É—é —Ñ–∏–∑–∏–∫—É (–±–µ–∑ –º–æ–¥–∏—Ñ–∏–∫–∞—Ç–æ—Ä–æ–≤):
    # –ï—Å–ª–∏ —Ö–æ—Ç–∏—Ç–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ –±–∞–∑–æ–≤—É—é —Ñ–∏–∑–∏–∫—É - –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –í–∞—Ä–∏–∞–Ω—Ç 1
    def test_bounce_off_table(self):
        """–¢–µ—Å—Ç –æ—Ç—Å–∫–æ–∫–∞ –æ—Ç —Å—Ç–æ–ª–∞ (–±–∞–∑–æ–≤—ã–π —Å–ª—É—á–∞–π)"""
        print("\nTest 3 - Table Bounce:")
        self.ball.reset_ball()
        self.ball.x, self.ball.y, self.ball.z = 400, 300, 0
        self.ball.vx, self.ball.vy, self.ball.vz = 0, 0, -4  # –¢–æ–ª—å–∫–æ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ
        
        self.print_ball_status("Before bounce")
        self.ball.update(0.1)
        self.print_ball_status("After bounce")
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ–ª—å–∫–æ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∏ –ø—Ä–∏–º–µ—Ä–Ω—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω
        self.assertGreater(self.ball.vz, 0)
        self.assertAlmostEqual(self.ball.vz, 4 * self.ball.bounce, delta=0.5)
    
    # –í–∞—Ä–∏–∞–Ω—Ç 2 - –¢–µ—Å—Ç–∏—Ä—É–µ–º –ø—Ä–æ–¥–≤–∏–Ω—É—Ç—É—é —Ñ–∏–∑–∏–∫—É (—Å –º–æ–¥–∏—Ñ–∏–∫–∞—Ç–æ—Ä–∞–º–∏):
    # –ï—Å–ª–∏ —Ç–µ—Å—Ç–∏—Ä—É–µ—Ç–µ –ø—Ä–æ–¥–≤–∏–Ω—É—Ç—É—é —Ñ–∏–∑–∏–∫—É - –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –í–∞—Ä–∏–∞–Ω—Ç 2
    def test_bounce_off_table(self):
        """–¢–µ—Å—Ç –æ—Ç—Å–∫–æ–∫–∞ –æ—Ç —Å—Ç–æ–ª–∞ (—Å —É—á—ë—Ç–æ–º –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ–π —Å–∫–æ—Ä–æ—Å—Ç–∏)"""
        print("\nTest 3 - Table Bounce:")
        self.ball.reset_ball()
        self.ball.x, self.ball.y, self.ball.z = 400, 300, 0
        self.ball.vx, self.ball.vy, self.ball.vz = 2, 0, -4
        
        expected_bounce = abs(-4) * (1 + 0.3 * abs(2)/10) * self.ball.bounce
        
        self.print_ball_status("Before bounce")
        self.ball.update(0.1)
        self.print_ball_status("After bounce")
        
        self.assertGreater(self.ball.vz, 0)
        self.assertAlmostEqual(self.ball.vz, expected_bounce, delta=0.1)
        
        self.assertAlmostEqual(self.ball.vz, expected_bounce, delta=0.1,
            msg=f"Expected vz ‚âà {expected_bounce}, got {self.ball.vz}")
                    

    def test_net_collision(self):
        """–¢–µ—Å—Ç —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è —Å —Å–µ—Ç–∫–æ–π"""
        print("\nTest 4 - Net Collision:")
        self.ball.reset_ball()
        net_pos = self.ball.table_height * 0.5
        self.ball.x, self.ball.y, self.ball.z = 400, net_pos, 30
        self.ball.vx, self.ball.vy, self.ball.vz = 5, 5, 0  # –õ–µ—Ç–∏–º –≤ —Å–µ—Ç–∫—É
        
        self.print_ball_status("Before net hit")
        self.ball.update(0.1)
        self.print_ball_status("After net hit")
        
        # –°–∫–æ—Ä–æ—Å—Ç–∏ –¥–æ–ª–∂–Ω—ã –∏–∑–º–µ–Ω–∏—Ç—å –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∏ —É–º–µ–Ω—å—à–∏—Ç—å—Å—è
        self.assertLess(abs(self.ball.vx), 5)
        self.assertLess(abs(self.ball.vy), 5)

    def test_pseudo_3d_projection(self):
        """–¢–µ—Å—Ç –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è 3D –≤ 2D –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã"""
        print("\nTest 5 - 3D Projection:")
        self.ball.reset_ball()
        self.ball.x, self.ball.y, self.ball.z = 400, 300, 20
        
        screen_x, screen_y = self.ball.get_screen_position()
        print(f"3D Position: (400, 300, 20) -> 2D Screen: ({screen_x:.1f}, {screen_y:.1f})")
        
        # –ß–µ–º –±–æ–ª—å—à–µ z –∏ –º–µ–Ω—å—à–µ y, —Ç–µ–º –≤—ã—à–µ –Ω–∞ —ç–∫—Ä–∞–Ω–µ (–º–µ–Ω—å—à–µ screen_y)
        self.assertLess(screen_y, 300)

    def test_out_of_bounds(self):
        """–¢–µ—Å—Ç –≤—ã—Ö–æ–¥–∞ –º—è—á–∞ –∑–∞ –ø—Ä–µ–¥–µ–ª—ã"""
        print("\nTest 6 - Out of Bounds:")
        self.ball.reset_ball()
        self.ball.y = self.ball.table_height * 1.3  # –£–ª–µ—Ç–µ–ª –∑–∞ –∏–≥—Ä–æ–∫–∞
        
        self.assertTrue(self.ball.is_out())
        print("Ball is out (behind player) -", self.ball.get_position())

'''
–≠—Ç–æ –ø–æ–∑–≤–æ–ª–∏—Ç –≤–∞–º:
    –í–∏–¥–µ—Ç—å –∫–∞–∫ –º–µ–Ω—è—é—Ç—Å—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Å –∫–∞–∂–¥—ã–º —à–∞–≥–æ–º
        –ù–∞–±–ª—é–¥–∞—Ç—å —ç—Ñ—Ñ–µ–∫—Ç—ã –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏–∏ –∏ –æ—Ç—Å–∫–æ–∫–æ–≤
        –ü—Ä–æ–≤–µ—Ä—è—Ç—å —É—Å–ª–æ–≤–∏—è –≤—ã—Ö–æ–¥–∞ –º—è—á–∞ –∑–∞ –ø—Ä–µ–¥–µ–ª—ã

–¢–µ—Å—Ç—ã –ø–æ–∫—Ä—ã–≤–∞—é—Ç:
    –ù–∞—á–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    –ì—Ä–∞–≤–∏—Ç–∞—Ü–∏—é
    –û—Ç—Å–∫–æ–∫–∏ –æ—Ç —Å—Ç–æ–ª–∞ –∏ —Å–µ—Ç–∫–∏
    –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ 3D‚Üí2D

–ì—Ä–∞–Ω–∏—á–Ω—ã–µ —É—Å–ª–æ–≤–∏—è
    –ö–∞–∫–∏–µ –µ—â—ë –∞—Å–ø–µ–∫—Ç—ã —Ñ–∏–∑–∏–∫–∏ –≤—ã —Ö–æ—Ç–µ–ª–∏ –±—ã –ø—Ä–æ—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å? –ù–∞–ø—Ä–∏–º–µ—Ä, –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —Ç–µ—Å—Ç—ã –¥–ª—è:
    –£–¥–∞—Ä–æ–≤ —Ä–∞–∫–µ—Ç–∫–æ–π (–º–µ—Ç–æ–¥ apply_hit())
    –†–∞–∑–Ω—ã—Ö —É–≥–ª–æ–≤ –æ—Ç—Å–∫–æ–∫–∞ –æ—Ç —Å—Ç–µ–Ω–æ–∫
    –≠—Ñ—Ñ–µ–∫—Ç–æ–≤ –≤—Ä–∞—â–µ–Ω–∏—è –º—è—á–∞
'''
def manual_test():
    """–†—É—á–Ω–æ–π —Ç–µ—Å—Ç —Å –ø–æ—à–∞–≥–æ–≤–æ–π —Å–∏–º—É–ª—è—Ü–∏–µ–π"""
    ball = BallPhysics(800, 600, 50)
    ball.reset_ball()
    
    print("\nManual Test Mode (press Enter to step, 'q' to quit):")
    step = 0
    while True:
        step += 1
        ball.update(0.1)
        x, y = ball.get_screen_position()
        print(f"Step {step}: 2D Pos=({x:.1f}, {y:.1f}) | 3D Pos={ball.get_position()}")
        
        if ball.is_out():
            print("Ball is out of bounds!")
            ball.reset_ball()
        
        if input().lower() == 'q':
            break

if __name__ == "__main__":
    unittest.main(verbosity=2)
    #manual_test()  # –†–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–π—Ç–µ –¥–ª—è —Ä—É—á–Ω–æ–≥–æ —Ç–µ—Å—Ç–∞








'''
from physics import BallPhysics

physics = BallPhysics(table_width=800, table_height=600, net_height=50)

while game_running:
    dt = clock.tick(60) / 1000.0  # –¥–µ–ª—å—Ç–∞ –≤—Ä–µ–º–µ–Ω–∏ –≤ —Å–µ–∫—É–Ω–¥–∞—Ö
    
    physics.update(dt)
    ball_pos = physics.get_screen_position()
    
    if physics.is_out():
        physics.reset_ball()
    
'''
</file>

<file path=".gitignore">
pycache/
venv/
*.pyc
*.log
.DS_Store
.idea
</file>

<file path="test_camera.py">
import cv2
import mediapipe as mp

mp_hands = mp.solutions.hands.Hands(max_num_hands=1)
cap = cv2.VideoCapture(0)

while True:
    ret, frame = cap.read()
    if not ret:
        break

    rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
    results = mp_hands.process(rgb)

    if results.multi_hand_landmarks:
        for hand_landmarks in results.multi_hand_landmarks:
            print("Hand detected:", hand_landmarks)

    cv2.imshow("Hand Tracking Test", frame)
    if cv2.waitKey(1) & 0xFF == 27:
        break

cap.release()
cv2.destroyAllWindows()
</file>

<file path="src/physics.py">
import math
import random


'''
–ö–ª—é—á–µ–≤—ã–µ –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏:
 - –£–ø—Ä–æ—â—ë–Ω–Ω–∞—è —Ñ–∏–∑–∏–∫–∞:
    - –ì—Ä–∞–≤–∏—Ç–∞—Ü–∏—è –≤–ª–∏—è–µ—Ç —Ç–æ–ª—å–∫–æ –Ω–∞ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—É—é –æ—Å—å (Z)
    - –û—Ç—Å–∫–æ–∫–∏ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é—Ç—Å—è –∏–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ–º —Å–∫–æ—Ä–æ—Å—Ç–∏ —Å –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–æ–º —É–ø—Ä—É–≥–æ—Å—Ç–∏
    - –î–æ–±–∞–≤–ª–µ–Ω–æ —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ –≤–æ–∑–¥—É—Ö–∞ –¥–ª—è —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω–æ—Å—Ç–∏

  - –ü—Å–µ–≤–¥–æ-3D —ç—Ñ—Ñ–µ–∫—Ç:
    - –ú–µ—Ç–æ–¥ get_screen_position() –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç 3D –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤ 2D —Å —É—á—ë—Ç–æ–º –ø–µ—Ä—Å–ø–µ–∫—Ç–∏–≤—ã
    - –ß–µ–º –¥–∞–ª—å—à–µ –º—è—á (–º–µ–Ω—å—à–µ y), —Ç–µ–º "–≤—ã—à–µ" –æ–Ω –æ—Ç–æ–±—Ä–∞–∂–∞–µ—Ç—Å—è

  - –°—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è:
    - –°–µ—Ç–∫–∞ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è –∫–∞–∫ –∑–æ–Ω–∞ –≤ —Å–µ—Ä–µ–¥–∏–Ω–µ —Å—Ç–æ–ª–∞ —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ–º –ø–æ –≤—ã—Å–æ—Ç–µ
    - –£–¥–∞—Ä—ã –æ —Å—Ç–æ–ª/—Å—Ç–µ–Ω–∫—É —Ç–µ—Ä—è—é—Ç —á–∞—Å—Ç—å —ç–Ω–µ—Ä–≥–∏–∏ (bounce –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç)

  - –°—Ç–∞—Ä—Ç –∏ —Å–±—Ä–æ—Å:
    –ü—Ä–∏ —Å–±—Ä–æ—Å–µ –º—è—á –ø–æ–ª—É—á–∞–µ—Ç —Å–ª—É—á–∞–π–Ω—ã–π –Ω–∞—á–∞–ª—å–Ω—ã–π —É–¥–∞—Ä –≤ —Å—Ç–æ—Ä–æ–Ω—É —Å—Ç–µ–Ω–∫–∏
'''



class BallPhysics:
    def __init__(self, table_width, table_height, net_height):
        """
        :param table_width: —à–∏—Ä–∏–Ω–∞ —Å—Ç–æ–ª–∞ (–≤ –ø–∏–∫—Å–µ–ª—è—Ö/—É—Å–ª–æ–≤–Ω—ã—Ö –µ–¥–∏–Ω–∏—Ü–∞—Ö)
        :param table_height: –¥–ª–∏–Ω–∞ —Å—Ç–æ–ª–∞ (–æ—Ç –∏–≥—Ä–æ–∫–∞ –¥–æ —Å—Ç–µ–Ω–∫–∏)
        :param net_height: –≤—ã—Å–æ—Ç–∞ —Å–µ—Ç–∫–∏ (–¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —É–¥–∞—Ä–∞)
        """
        self.table_width = table_width
        self.table_height = table_height
        self.net_height = net_height
        
        # –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –º—è—á–∞ (—Å—Ç–∞—Ä—Ç–æ–≤–∞—è –ø–æ–∑–∏—Ü–∏—è –∏ —Å–∫–æ—Ä–æ—Å—Ç—å)
        self.reset_ball()
        
        # –§–∏–∑–∏—á–µ—Å–∫–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
        self.gravity = 0.2  # "—Ç—è–∂–µ—Å—Ç—å" –º—è—á–∞
        self.drag = 0.99    # —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ –≤–æ–∑–¥—É—Ö–∞
        self.bounce = 0.7   # —É–ø—Ä—É–≥–æ—Å—Ç—å –æ—Ç—Å–∫–æ–∫–∞
        
    def reset_ball(self):
        """–°–±—Ä–æ—Å –º—è—á–∞ –≤ –Ω–∞—á–∞–ª—å–Ω–æ–µ –ø–æ–ª–æ–∂–µ–Ω–∏–µ (—Å–ª—É—á–∞–π–Ω—ã–π –Ω–∞—á–∞–ª—å–Ω—ã–π —É–¥–∞—Ä)"""
        self.x = self.table_width / 2
        self.y = self.table_height - 50  # —Å—Ç–∞—Ä—Ç —É –∏–≥—Ä–æ–∫–∞
        self.z = 0  # "–≤—ã—Å–æ—Ç–∞" –º—è—á–∞ (–ø—Å–µ–≤–¥–æ-3D)
        
        # –ù–∞—á–∞–ª—å–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å (—Å–ª—É—á–∞–π–Ω—ã–π –ª–µ–≥–∫–∏–π —É–¥–∞—Ä –∫ —Å—Ç–µ–Ω–∫–µ)
        self.vx = random.uniform(-2, 2)
        self.vy = -random.uniform(8, 10)  # –≤ —Å—Ç–æ—Ä–æ–Ω—É —Å—Ç–µ–Ω—ã (–æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ)
        self.vz = random.uniform(5, 7)
    
    def update(self, dt):
        """
        –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –º—è—á–∞ —Å —É—á—ë—Ç–æ–º —Ñ–∏–∑–∏–∫–∏
        :param dt: –≤—Ä–µ–º—è —Å –ø—Ä–æ—à–ª–æ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è (–¥–ª—è –ø–ª–∞–≤–Ω–æ—Å—Ç–∏)
        """
        # –ü—Ä–∏–º–µ–Ω—è–µ–º –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏—é –∫ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–π —Å–∫–æ—Ä–æ—Å—Ç–∏
        self.vz -= self.gravity
        
        # –î–≤–∏–∂–µ–Ω–∏–µ –º—è—á–∞
        self.x += self.vx * dt
        self.y += self.vy * dt
        self.z += self.vz * dt
        
        # –ü—Ä–∏–º–µ–Ω—è–µ–º —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ –≤–æ–∑–¥—É—Ö–∞
        self.vx *= self.drag
        self.vy *= self.drag
        self.vz *= self.drag
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π
        self._check_collisions()
        
    def _check_collisions(self):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Å–µ—Ö —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π (—Å—Ç–æ–ª, —Å–µ—Ç–∫–∞, —Å—Ç–µ–Ω–∫–∞)"""
        # –°—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ —Å –ª–µ–≤–æ–π/–ø—Ä–∞–≤–æ–π –≥—Ä–∞–Ω–∏—Ü–µ–π —Å—Ç–æ–ª–∞
        if self.x <= 0 or self.x >= self.table_width:
            self.vx = -self.vx * self.bounce
            self.x = max(0, min(self.table_width, self.x))
        
        # –°—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ —Å —Å–µ—Ç–∫–æ–π (–ø–æ—Å–µ—Ä–µ–¥–∏–Ω–µ —Å—Ç–æ–ª–∞)
        net_pos = self.table_height * 0.5  # —Å–µ—Ç–∫–∞ –Ω–∞ –ø–æ–ª–æ–≤–∏–Ω–µ —Å—Ç–æ–ª–∞
        net_width = self.table_width * 0.1  # —à–∏—Ä–∏–Ω–∞ —Å–µ—Ç–∫–∏
        
        if (abs(self.y - net_pos) < net_width and 
            self.z < self.net_height and 
            (self.vx != 0 or self.vy != 0)):
            
            # –ú—è—á —É–¥–∞—Ä–∏–ª—Å—è –≤ —Å–µ—Ç–∫—É - –æ—Ç—Å–∫–æ–∫ —Å –ø–æ—Ç–µ—Ä–µ–π —Å–∫–æ—Ä–æ—Å—Ç–∏
            self.vx *= -0.5
            self.vy *= -0.5
            self.vz *= 0.3
            return True  # –í–æ–∑–≤—Ä–∞—â–∞–µ–º True –¥–ª—è –∑–≤—É–∫–æ–≤–æ–≥–æ —ç—Ñ—Ñ–µ–∫—Ç–∞
        
        # –°—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ —Å–æ —Å—Ç–µ–Ω–∫–æ–π (–¥–∞–ª—å–Ω–∏–π –∫—Ä–∞–π)
        if self.y <= 0:
            self.vy = -self.vy * self.bounce
            self.y = 0
            self.vz *= 0.8  # —Ç–µ—Ä—è–µ–º –Ω–µ–º–Ω–æ–≥–æ —ç–Ω–µ—Ä–≥–∏–∏ –ø—Ä–∏ —É–¥–∞—Ä–µ –æ —Å—Ç–µ–Ω–∫—É
        
        # –°—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ —Å "–ø–æ–ª–æ–º" (—Å—Ç–æ–ª–æ–º)
        # –î–ª—è –±–æ–ª—å—à–µ–π –∑—Ä–µ–ª–∏—â–Ω–æ—Å—Ç–∏ –¥–æ–±–∞–≤—å—Ç–µ:
        # if self.z <= 0:  # –ü—Ä–∏ —É–¥–∞—Ä–µ –æ —Å—Ç–æ–ª
            # sparkle_effect(self.x, self.y)  # –í–∏–∑—É–∞–ª—å–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç
        
        # –í physics.py –≤–Ω—É—Ç—Ä–∏ _check_collisions():
        if self.z <= 0:
            self.z = 0
            # –ú–æ–¥–∏—Ñ–∏–∫–∞—Ç–æ—Ä –æ—Ç –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ–π —Å–∫–æ—Ä–æ—Å—Ç–∏
            bounce_power = abs(self.vz) * (1 + 0.3 * abs(self.vx)/10)
            self.vz = bounce_power * self.bounce
            
            if abs(self.vz) < 0.1:
                self.vz = 0
                
        return False
    
    def is_out(self):
        """–ü—Ä–æ–≤–µ—Ä–∫–∞, —É–ª–µ—Ç–µ–ª –ª–∏ –º—è—á –∑–∞ –ø—Ä–µ–¥–µ–ª—ã –∏–≥—Ä–æ–≤–æ–π –∑–æ–Ω—ã"""
        return (self.y > self.table_height * 1.2 or  # —É–ª–µ—Ç–µ–ª –∑–∞ –∏–≥—Ä–æ–∫–∞
                abs(self.x - self.table_width/2) > self.table_width * 0.6 or  # –≤–±–æ–∫
                self.z > 50)  # —Å–ª–∏—à–∫–æ–º –≤—ã—Å–æ–∫–æ
    
    def get_position(self):
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–æ–∑–∏—Ü–∏—é –º—è—á–∞ –≤ —Ñ–æ—Ä–º–∞—Ç–µ (x, y, z)"""
        return (self.x, self.y, self.z)
    
    def get_screen_position(self, perspective_factor=0.5):
        """
        –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç 3D –ø–æ–∑–∏—Ü–∏—é –≤ 2D –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –¥–ª—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∏ —Å –ø—Å–µ–≤–¥–æ-3D —ç—Ñ—Ñ–µ–∫—Ç–æ–º
        :param perspective_factor: —Å–∏–ª–∞ –ø–µ—Ä—Å–ø–µ–∫—Ç–∏–≤—ã (0-1)
        """
        # –ß–µ–º –¥–∞–ª—å—à–µ –º—è—á (–º–µ–Ω—å—à–µ y), —Ç–µ–º –≤—ã—à–µ –æ–Ω –Ω–∞ —ç–∫—Ä–∞–Ω–µ (–∏–º–∏—Ç–∞—Ü–∏—è 3D)
        screen_y = self.table_height - self.y - self.z * perspective_factor
        return (self.x, screen_y)
    
    # –î–ª—è —Å–µ—Ç–µ–≤–æ–≥–æ –æ–±–º–µ–Ω–∞
    def get_state(self):
        return (self.x, self.y, self.z, self.vx, self.vy, self.vz)
    
    def set_state(self, state):
        self.x, self.y, self.z, self.vx, self.vy, self.vz = state
</file>

<file path="README.md">
# üèì Gesture Pong

–ò–≥—Ä–∞ –≤ –Ω–∞—Å—Ç–æ–ª—å–Ω—ã–π —Ç–µ–Ω–Ω–∏—Å (Pong), —É–ø—Ä–∞–≤–ª—è–µ–º–∞—è –¥–≤–∏–∂–µ–Ω–∏–µ–º —Ä—É–∫–∏ —á–µ—Ä–µ–∑ –≤–µ–±–∫–∞–º–µ—Ä—É —Å –ø–æ–º–æ—â—å—é OpenCV + Mediapipe.
üöÄ –ü–æ–ª–Ω–æ—Å—Ç—å—é –ª–æ–∫–∞–ª—å–Ω–æ, –±–µ–∑ –æ—Ç–ø—Ä–∞–≤–∫–∏ –¥–∞–Ω–Ω—ã—Ö –≤ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç.

---

## üöÄ –ë—ã—Å—Ç—Ä—ã–π —Å—Ç–∞—Ä—Ç

### 1Ô∏è‚É£ –°–∫–ª–æ–Ω–∏—Ä—É–π—Ç–µ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π

```bash
git clone https://github.com/Kb-Kirill/pong-hackathon
cd gesture-pong
```

### 2Ô∏è‚É£ –°–æ–∑–¥–∞–π—Ç–µ –≤–∏—Ä—Ç—É–∞–ª—å–Ω–æ–µ –æ–∫—Ä—É–∂–µ–Ω–∏–µ

```bash
python -m venv venv
source venv/bin/activate  # Windows: venv\Scripts\activate
```

### 3Ô∏è‚É£ –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏

```bash
pip install -r requirements.txt
```

---

## üîß –ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏

* `pygame` ‚Äî –¥–ª—è –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏ –∏–≥—Ä—ã
* `opencv-python` ‚Äî –∑–∞—Ö–≤–∞—Ç –∏ –æ–±—Ä–∞–±–æ—Ç–∫–∞ –≤–∏–¥–µ–æ
* `mediapipe` ‚Äî –¥–µ—Ç–µ–∫—Ü–∏—è —Ä—É–∫–∏ (–∏–ª–∏ –¥—Ä—É–≥–∏—Ö —á–∞—Å—Ç–µ–π —Ç–µ–ª–∞)

–°–º. [`requirements.txt`](./requirements.txt) –¥–ª—è –≤–µ—Ä—Å–∏–π.

---

## üñ• –°–∏—Å—Ç–µ–º–Ω—ã–µ –ø–∞–∫–µ—Ç—ã

### Linux

```bash
sudo apt update
sudo apt install libgl1 libgtk-3-dev
```

(–Ω–µ–æ–±—Ö–æ–¥–∏–º—ã –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–π —Ä–∞–±–æ—Ç—ã OpenCV, –æ—Ç–∫—Ä—ã—Ç–∏—è –æ–∫–æ–Ω –∏ —Ç.–¥.)

–ù–∞ Windows / MacOS –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ –Ω–∏—á–µ–≥–æ –Ω–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è.

---

## ‚úÖ –¢–µ—Å—Ç –∫–∞–º–µ—Ä—ã –∏ Mediapipe

–î–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫–∞–º–µ—Ä—ã –∏ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è —Ä—É–∫–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Å–∫—Ä–∏–ø—Ç `test_camera.py`.

### üìÇ –ó–∞–ø—É—Å–∫

```bash
python test_camera.py
```

–ï—Å–ª–∏ —Ä—É–∫–∞ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∞, –≤ –∫–æ–Ω—Å–æ–ª–∏ –±—É–¥—É—Ç –ø–æ—è–≤–ª—è—Ç—å—Å—è —Å–æ–æ–±—â–µ–Ω–∏—è:

```
Hand detected: landmark ...
```

–∞ –≤ –æ–∫–Ω–µ –ø–æ—è–≤–∏—Ç—Å—è –≤–∏–¥–µ–æ —Å –∫–∞–º–µ—Ä—ã.

---

## ‚ö† –ï—Å–ª–∏ –∫–∞–º–µ—Ä–∞ –Ω–µ –æ—Ç–∫—Ä—ã–≤–∞–µ—Ç—Å—è

* –ó–∞–∫—Ä–æ–π –¥—Ä—É–≥–∏–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è (Zoom, Discord –∏ –¥—Ä.), –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥—É—Ç –µ—ë –±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å.
* –ü–æ–ø—Ä–æ–±—É–π —Å–º–µ–Ω–∏—Ç—å –∏–Ω–¥–µ–∫—Å:

  ```python
  cap = cv2.VideoCapture(1)
  ```
* –î–ª—è Linux –º–æ–∂–Ω–æ –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞:

  ```bash
  ls /dev/video*
  ```
---

## üìú –õ–∏—Ü–µ–Ω–∑–∏—è

MIT ¬© 2025 ‚Äî –°–¥–µ–ª–∞–Ω–æ –¥–ª—è —Ö–∞–∫–∞—Ç–æ–Ω–∞ ‚ö°
</file>

<file path="requirements.txt">
pygame
opencv-python
mediapipe
numpy
websockets  # –¥–ª—è PvP
</file>

<file path="src/hand_tracker.py">
import cv2
import mediapipe as mp
import numpy as np


class HandTracker:
    def __init__(self, max_num_hands=1, min_detection_confidence=0.7, min_tracking_confidence=0.5):
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Mediapipe
        self.mp_hands = mp.solutions.hands
        self.mp_drawing = mp.solutions.drawing_utils
        self.hands = self.mp_hands.Hands(
            max_num_hands=max_num_hands,
            min_detection_confidence=min_detection_confidence,
            min_tracking_confidence=min_tracking_confidence
        )
        self.cap = None

    def start_capture(self):
        """–ó–∞–ø—É—Å–∫–∞–µ—Ç –∑–∞—Ö–≤–∞—Ç –≤–∏–¥–µ–æ —Å –≤–µ–±-–∫–∞–º–µ—Ä—ã."""
        self.cap = cv2.VideoCapture(0)
        if not self.cap.isOpened():
            raise RuntimeError("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –≤–µ–±-–∫–∞–º–µ—Ä—É")

    def stop_capture(self):
        """–û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –∑–∞—Ö–≤–∞—Ç –∏ –æ—Å–≤–æ–±–æ–∂–¥–∞–µ—Ç —Ä–µ—Å—É—Ä—Å—ã."""
        if self.cap:
            self.cap.release()
        cv2.destroyAllWindows()
        self.hands.close()

    def process_frame(self, draw_point=True):
        """
        –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Ç–µ–∫—É—â–∏–π –∫–∞–¥—Ä, –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Ü–µ–Ω—Ç—Ä–∞ –ª–∞–¥–æ–Ω–∏.
        Args:
            draw_point: bool, —Ä–∏—Å–æ–≤–∞—Ç—å –ª–∏ —Ç–æ—á–∫—É –≤ —Ü–µ–Ω—Ç—Ä–µ –ª–∞–¥–æ–Ω–∏
        Returns:
            tuple: (frame, normalized_coords), –≥–¥–µ normalized_coords - (x, y) –∏–ª–∏ None
        """
        if not self.cap or not self.cap.isOpened():
            return None, None

        ret, frame = self.cap.read()
        if not ret:
            return None, None

        frame = cv2.flip(frame, 1)
        # –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è BGR –≤ RGB
        frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)

        # –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–∞–¥—Ä–∞
        results = self.hands.process(frame_rgb)

        # –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –æ–±—Ä–∞—Ç–Ω–æ –≤ BGR –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
        frame = cv2.cvtColor(frame_rgb, cv2.COLOR_RGB2BGR)

        normalized_coords = None
        if results.multi_hand_landmarks:
            for hand_landmarks in results.multi_hand_landmarks:
                # –†–∏—Å—É–µ–º landmarks –Ω–∞ —Ä—É–∫–µ
                self.mp_drawing.draw_landmarks(frame, hand_landmarks, self.mp_hands.HAND_CONNECTIONS)

                # –ü–æ–ª—É—á–∞–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Ü–µ–Ω—Ç—Ä–∞ –ª–∞–¥–æ–Ω–∏ (landmark 0 - –æ—Å–Ω–æ–≤–∞–Ω–∏–µ –ª–∞–¥–æ–Ω–∏)
                palm_center = hand_landmarks.landmark[0]
                h, w, _ = frame.shape
                cx = int(palm_center.x * w)
                cy = int(palm_center.y * h)

                # –†–∏—Å—É–µ–º —Ç–æ—á–∫—É –≤ —Ü–µ–Ω—Ç—Ä–µ –ª–∞–¥–æ–Ω–∏, –µ—Å–ª–∏ —Ç—Ä–µ–±—É–µ—Ç—Å—è
                if draw_point:
                    cv2.circle(frame, (cx, cy), 10, (0, 255, 0), -1)

                # –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
                normalized_coords = (palm_center.x, palm_center.y)

        return frame, normalized_coords

    def run(self):
        """–ó–∞–ø—É—Å–∫–∞–µ—Ç –æ—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º –æ–∫–Ω–∞."""
        self.start_capture()
        try:
            while self.cap.isOpened():
                frame, coords = self.process_frame()
                if frame is None:
                    break

                # –û—Ç–æ–±—Ä–∞–∂–∞–µ–º –∫–∞–¥—Ä
                cv2.imshow('Hand Tracker', frame)

                # –í—ã–≤–æ–¥–∏–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤ –∫–æ–Ω—Å–æ–ª—å, –µ—Å–ª–∏ –æ–Ω–∏ –µ—Å—Ç—å
                if coords:
                    print(f"Normalized coords: x={coords[0]:.3f}, y={coords[1]:.3f}")

                # –í—ã—Ö–æ–¥ –ø–æ –Ω–∞–∂–∞—Ç–∏—é 'q'
                if cv2.waitKey(1) & 0xFF == ord('q'):
                    break
        finally:
            self.stop_capture()
</file>

<file path="src/game.py">
import cv2
import pygame
import os
from hand_tracker import HandTracker
import random
import math
import time

random.seed(time.time())

# --- –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —ç–∫—Ä–∞–Ω–∞ ---
WIDTH, HEIGHT = 1200, 800

# --- –¶–≤–µ—Ç–∞ ---
BG_COLOR = (30, 30, 30)
TABLE_COLOR = (1, 101, 163)  # –°–∏–Ω–µ-–≥–æ–ª—É–±–æ–π —Ü–≤–µ—Ç —Å—Ç–æ–ª–∞
NET_COLOR = (255, 255, 255)
BALL_COLOR = (255, 255, 0)
BUTTON_COLOR = (175, 238, 27)  # –ó–µ–ª–µ–Ω—ã–π –¥–ª—è –∫–Ω–æ–ø–æ–∫
BUTTON_HOVER_COLOR = (45, 62, 71)  # –°–µ—Ä—ã–π –ø—Ä–∏ –Ω–∞–≤–µ–¥–µ–Ω–∏–∏
BUTTON_TEXT_COLOR = (255, 255, 255)  # –ë–µ–ª—ã–π —Ç–µ–∫—Å—Ç –Ω–∞ –∫–Ω–æ–ø–∫–∞—Ö
SCORE_COLOR = (255, 255, 255)  # –ë–µ–ª—ã–π –¥–ª—è —Å—á—ë—Ç–∞
SHADOW_COLOR = (100, 100, 100)  # –°–µ—Ä—ã–π –¥–ª—è —Ç–µ–Ω–∏ –º—è—á–∞
# –í –Ω–∞—á–∞–ª–µ —Ñ–∞–π–ª–∞, –≥–¥–µ –æ–±—ä—è–≤–ª–µ–Ω—ã –¥—Ä—É–≥–∏–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã, –¥–æ–±–∞–≤—å—Ç–µ:
MIN_BALL_ANGLE = math.pi / 6  # 20 –≥—Ä–∞–¥—É—Å–æ–≤ (–º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —É–≥–æ–ª –æ—Ç –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏)
MAX_BALL_ANGLE = math.pi / 3  # 70 –≥—Ä–∞–¥—É—Å–æ–≤ (–º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —É–≥–æ–ª –æ—Ç –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏)


# --- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è pygame ---
pygame.init()
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Table Tennis Wall")
clock = pygame.time.Clock()

# --- –®—Ä–∏—Ñ—Ç—ã ---
font_menu = pygame.font.SysFont("arial", 48)
font = pygame.font.SysFont("arial", 40)  # –®—Ä–∏—Ñ—Ç –¥–ª—è —Å—á—ë—Ç–∞ –∏ –∫–Ω–æ–ø–æ–∫

# --- –§–æ–Ω–æ–≤–∞—è –º—É–∑—ã–∫–∞ ---
script_dir = os.path.dirname(os.path.abspath(__file__))
music_path = os.path.join(script_dir, "..", "assets", "sound", "1.mp3")
pygame.mixer.init()
pygame.mixer.music.load(music_path)
pygame.mixer.music.set_volume(0.4)
pygame.mixer.music.play(-1)

# --- –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Å—Ç–æ–ª–∞ (–≥–ª–æ–±–∞–ª—å–Ω—ã–µ) ---
table_top_width = WIDTH * 0.25  # –í–µ—Ä—Ö–Ω—è—è —á–∞—Å—Ç—å —Å—Ç–æ–ª–∞ (—É–∑–∫–∞—è)
table_bottom_width = WIDTH * 0.6  # –ù–∏–∂–Ω—è—è —á–∞—Å—Ç—å —Å—Ç–æ–ª–∞
table_top_y = 250
table_bottom_y = HEIGHT - int(0.2 * HEIGHT)

# --- –ù–∞—á–∞–ª—å–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏ –∏ —Å–æ—Å—Ç–æ—è–Ω–∏–µ ---
ball_pos = [WIDTH // 2, HEIGHT // 3]
ball_velocity = [5, 5]  # –ù–∞—á–∞–ª—å–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å –º—è—á–∞
paddle_pos = [WIDTH // 2 - 70, HEIGHT - 140]  # x, y (—Å–º–µ—â–µ–Ω–æ –¥–ª—è —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏—è —Ä–∞–∫–µ—Ç–∫–∏)
player_score = 0  # –°—á—ë—Ç –∏–≥—Ä–æ–∫–∞
opponent_score = 0  # –°—á—ë—Ç —Å—Ç–µ–Ω–∫–∏/–ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞
paddle_collision_cooldown = 0  # –¢–∞–π–º–µ—Ä –¥–ª—è –∑–∞–¥–µ—Ä–∂–∫–∏ –º–µ–∂–¥—É —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è–º–∏

# --- –ó–∞–≥—Ä—É–∑–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è —Ä–∞–∫–µ—Ç–∫–∏ ---
paddle_image_path = os.path.join(script_dir, "..", "assets", "image", "paddle.png")
paddle_image = pygame.image.load(paddle_image_path).convert_alpha()
paddle_image = pygame.transform.scale(paddle_image, (140, 140))

# --- –ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–æ–Ω–æ–≤–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å—Ç–æ–ª–∞ ---
table_bg_image_path = os.path.join(script_dir, "..", "assets", "image", "boss.png")
table_bg_image = pygame.image.load(table_bg_image_path).convert_alpha()

# --- –ó–∞–≥—Ä—É–∑–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –º—è—á–∞ ---
ball_image_path = os.path.join(script_dir, "..", "assets", "image", "ball.png")
ball_image = pygame.image.load(ball_image_path).convert_alpha()
ball_image = pygame.transform.scale(ball_image, (50, 50))  # –ü–æ–¥ —Ä–∞–∑–º–µ—Ä –∫–∞–∫ –±—ã–ª –∫—Ä—É–≥

# --- –ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–æ–Ω–æ–≤–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –≤—Å–µ–≥–æ –æ–∫–Ω–∞ ---
background_image_path = os.path.join(script_dir, "..", "assets", "image", "background.jpg")
background_image = pygame.image.load(background_image_path).convert()
background_image = pygame.transform.scale(background_image, (WIDTH, HEIGHT))


# --- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è HandTracker ---
tracker = HandTracker(max_num_hands=1)
tracker.start_capture()

# –í –Ω–∞—á–∞–ª–µ —Ñ–∞–π–ª–∞, –≥–¥–µ –æ–±—ä—è–≤–ª—è—é—Ç—Å—è –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ, –¥–æ–±–∞–≤—å—Ç–µ:
paddle_collision_cooldown = 0  # –¢–∞–π–º–µ—Ä –¥–ª—è –∑–∞–¥–µ—Ä–∂–∫–∏ –º–µ–∂–¥—É —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è–º–∏

# --- –°–æ—Å—Ç–æ—è–Ω–∏—è –∏–≥—Ä—ã ---
MENU = "menu"
GAME = "game"
game_state = MENU

def draw_menu():
    screen.fill(BG_COLOR)
    # –ö–Ω–æ–ø–∫–∞ "–ù–∞—á–∞—Ç—å"
    button_rect = pygame.Rect(WIDTH // 2 - 100, HEIGHT // 2 - 50, 200, 100)
    mouse_pos = pygame.mouse.get_pos()
    if button_rect.collidepoint(mouse_pos):
        pygame.draw.rect(screen, BUTTON_HOVER_COLOR, button_rect)
    else:
        pygame.draw.rect(screen, BUTTON_COLOR, button_rect)

    # –¢–µ–∫—Å—Ç –∫–Ω–æ–ø–∫–∏
    text = font_menu.render("–ù–∞—á–∞—Ç—å", True, BUTTON_TEXT_COLOR)
    text_rect = text.get_rect(center=button_rect.center)
    screen.blit(text, text_rect)

def draw_scene(frame_surface=None):
    screen.blit(background_image, (0, 0))

    # –û–∫–Ω–æ –∫–∞–º–µ—Ä—ã
    if frame_surface:
        camera_rect = pygame.Rect(WIDTH - 330, 10, 320, 240)
        screen.blit(frame_surface, camera_rect)

    # –õ–µ–≤–∞—è –ø–æ–ª–æ–≤–∏–Ω–∞ —Å—Ç–æ–ª–∞
    left_table_points = [
        (WIDTH // 2, table_top_y),
        (WIDTH // 2 - table_top_width // 2, table_top_y),
        (WIDTH // 2 - table_bottom_width // 2, table_bottom_y),
        (WIDTH // 2, table_bottom_y)
    ]
    pygame.draw.polygon(screen, TABLE_COLOR, left_table_points)

    # –ü—Ä–∞–≤–∞—è –ø–æ–ª–æ–≤–∏–Ω–∞ —Å—Ç–æ–ª–∞
    right_table_points = [
        (WIDTH // 2, table_top_y),
        (WIDTH // 2 + table_top_width // 2, table_top_y),
        (WIDTH // 2 + table_bottom_width // 2, table_bottom_y),
        (WIDTH // 2, table_bottom_y)
    ]
    pygame.draw.polygon(screen, TABLE_COLOR, right_table_points)

    # –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –ª–∏–Ω–∏—è
    pygame.draw.line(screen, NET_COLOR, (WIDTH // 2, table_top_y), (WIDTH // 2, table_bottom_y), 3)

    # --- –ù–æ–∂–∫–∏ —Å—Ç–æ–ª–∞ ---
    leg_width = 20
    leg_color = (50, 50, 50)  # –¢—ë–º–Ω–æ-—Å–µ—Ä—ã–π —Ü–≤–µ—Ç –Ω–æ–∂–µ–∫

    # –õ–µ–≤–∞—è –Ω–æ–∂–∫–∞
    left_leg_x = WIDTH // 2 - table_bottom_width // 2 + 100  # –Ω–µ–º–Ω–æ–≥–æ –≤–Ω—É—Ç—Ä—å
    left_leg_y = table_bottom_y
    left_leg_height = HEIGHT - table_bottom_y
    pygame.draw.rect(screen, leg_color, (left_leg_x, left_leg_y, leg_width, left_leg_height))

    # –ü—Ä–∞–≤–∞—è –Ω–æ–∂–∫–∞
    right_leg_x = WIDTH // 2 + table_bottom_width // 2 - leg_width - 100  # –Ω–µ–º–Ω–æ–≥–æ –≤–Ω—É—Ç—Ä—å
    right_leg_y = table_bottom_y
    right_leg_height = HEIGHT - table_bottom_y
    pygame.draw.rect(screen, leg_color, (right_leg_x, right_leg_y, leg_width, right_leg_height))


    # --- –í—Ç–æ—Ä–æ–π –∏–≥—Ä–æ–∫ (boss) ---
    boss_width = 132
    boss_height = 200
    boss_x = WIDTH // 2 - boss_width // 2
    boss_y = table_top_y - boss_height
    boss_image_scaled = pygame.transform.scale(table_bg_image, (boss_width, boss_height))
    screen.blit(boss_image_scaled, (boss_x, boss_y))

    # --- –°–µ—Ç–∫–∞ ---
    net_y = table_top_y + int((table_bottom_y - table_top_y) * 0.38)
    net_width = (table_top_width + (table_bottom_width - table_top_width) *
                 ((net_y - table_top_y) / (table_bottom_y - table_top_y))) * 1.07
    net_half_width = net_width // 2
    for y in range(net_y - 25, net_y + 25, 6):
        for x in range(-int(net_half_width), int(net_half_width), 6):
            pygame.draw.rect(screen, NET_COLOR, (WIDTH // 2 + x, y, 2, 2))

    # --- –¢–µ–Ω—å –º—è—á–∞ ---
    # –£—Å–ª–æ–≤–Ω–∞—è –≤—ã—Å–æ—Ç–∞ Z: 0 —É table_bottom_y, 1 —É table_top_y
    z = (table_bottom_y - ball_pos[1]) / (table_bottom_y - table_top_y)
    z = max(0, min(1, z))  # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º Z –≤ [0, 1]
    # –†–∞–∑–º–µ—Ä —Ç–µ–Ω–∏: –æ—Ç 30x20 (Z=0) –¥–æ 15x10 (Z=1)
    shadow_width = int(30 - 15 * z)
    shadow_height = int(20 - 10 * z)
    # –°–º–µ—â–µ–Ω–∏–µ —Ç–µ–Ω–∏ –≤–Ω–∏–∑: –æ—Ç 0 (Z=0) –¥–æ 40 (Z=1)
    shadow_offset_y = int(40 * z)
    # –ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å —Ç–µ–Ω–∏: –æ—Ç 180 (Z=0) –¥–æ 40 (Z=1)
    shadow_alpha = int(180 - 140 * z)
    # –°–æ–∑–¥–∞—ë–º –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å –¥–ª—è —Ç–µ–Ω–∏
    shadow_surface = pygame.Surface((shadow_width, shadow_height), pygame.SRCALPHA)
    pygame.draw.ellipse(shadow_surface, (*SHADOW_COLOR, shadow_alpha), (0, 0, shadow_width, shadow_height))
    shadow_pos = (ball_pos[0] - shadow_width // 2, ball_pos[1] + shadow_offset_y - shadow_height // 2)
    screen.blit(shadow_surface, shadow_pos)

    # –ú—è—á —Å —Ç–µ–∫—Å—Ç—É—Ä–æ–π
    ball_rect = ball_image.get_rect(center=ball_pos)
    screen.blit(ball_image, ball_rect)

    # –†–∞–∫–µ—Ç–∫–∞
    screen.blit(paddle_image, paddle_pos)

    # –°—á—ë—Ç
    score_text = font.render(f"{player_score}:{opponent_score}", True, SCORE_COLOR)
    score_rect = score_text.get_rect(center=(WIDTH // 2, 50))
    screen.blit(score_text, score_rect)

    # –ö–Ω–æ–ø–∫–∏
    menu_button_rect = pygame.Rect(20, 20, 150, 50)
    restart_button_rect = pygame.Rect(190, 20, 150, 50)

    mouse_pos = pygame.mouse.get_pos()
    if menu_button_rect.collidepoint(mouse_pos):
        pygame.draw.rect(screen, BUTTON_HOVER_COLOR, menu_button_rect)
    else:
        pygame.draw.rect(screen, BUTTON_COLOR, menu_button_rect)
    menu_text = font.render("–í –º–µ–Ω—é", True, BUTTON_TEXT_COLOR)
    screen.blit(menu_text, menu_button_rect.move(20, 5))

    if restart_button_rect.collidepoint(mouse_pos):
        pygame.draw.rect(screen, BUTTON_HOVER_COLOR, restart_button_rect)
    else:
        pygame.draw.rect(screen, BUTTON_COLOR, restart_button_rect)
    restart_text = font.render("–ù–∞—á–∞—Ç—å", True, BUTTON_TEXT_COLOR)
    screen.blit(restart_text, restart_button_rect.move(15, 5))

    return menu_button_rect, restart_button_rect

# --- –ì–ª–∞–≤–Ω—ã–π –∏–≥—Ä–æ–≤–æ–π —Ü–∏–∫–ª ---
running = True
while running:
    # –°–æ–±—ã—Ç–∏—è
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        elif event.type == pygame.MOUSEBUTTONDOWN:
            mouse_pos = event.pos
            if game_state == MENU:
                # –ö–Ω–æ–ø–∫–∞ "–ù–∞—á–∞—Ç—å" –≤ –º–µ–Ω—é
                button_rect = pygame.Rect(WIDTH // 2 - 100, HEIGHT // 2 - 50, 200, 100)
                if button_rect.collidepoint(mouse_pos):
                    game_state = GAME
                    player_score = 0  # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—á—ë—Ç –∏–≥—Ä–æ–∫–∞
                    opponent_score = 0  # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—á—ë—Ç –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞
                    ball_pos = [WIDTH // 2, HEIGHT // 3]  # –°–±—Ä–æ—Å –ø–æ–∑–∏—Ü–∏–∏ –º—è—á–∞
                    reset_angle = random.uniform(MIN_BALL_ANGLE, MAX_BALL_ANGLE)  # –°–ª—É—á–∞–π–Ω—ã–π —É–≥–æ–ª –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ
                    speed = random.uniform(6, 8)  # –°–ª—É—á–∞–π–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å
                    # –ù–∞—á–∞–ª—å–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å –º—è—á–∞
                    ball_velocity = [
                        speed * math.cos(reset_angle) * random.choice([-1, 1]),
                        speed * math.sin(reset_angle) 
                    ]
            elif game_state == GAME:
                # –ö–Ω–æ–ø–∫–∏ –≤ –∏–≥—Ä–µ
                menu_button_rect, restart_button_rect = draw_scene()
                if menu_button_rect.collidepoint(mouse_pos):
                    game_state = MENU  # –í–æ–∑–≤—Ä–∞—Ç –≤ –º–µ–Ω—é
                elif restart_button_rect.collidepoint(mouse_pos):
                    player_score = 0  # –°–±—Ä–æ—Å —Å—á—ë—Ç–∞ –∏–≥—Ä–æ–∫–∞
                    opponent_score = 0  # –°–±—Ä–æ—Å —Å—á—ë—Ç–∞ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞
                    ball_pos = [WIDTH // 2, HEIGHT // 3]  # –°–±—Ä–æ—Å –ø–æ–∑–∏—Ü–∏–∏ –º—è—á–∞
                    paddle_pos = [WIDTH // 2 - 70, HEIGHT - 140]  # –°–±—Ä–æ—Å –ø–æ–∑–∏—Ü–∏–∏ —Ä–∞–∫–µ—Ç–∫–∏
                    ball_velocity = [random.choice([-5, 5]), 5] # –ü—Ä–∏ —Å–±—Ä–æ—Å–µ –º—è—á–∞ –¥–æ–±–∞–≤—å—Ç–µ —Å–ª—É—á–∞–π–Ω–æ—Å—Ç—å:

    # --- –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è ---
    if game_state == GAME:
        # –ü–æ–ª—É—á–∞–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Ä—É–∫–∏ –∏ –∫–∞–¥—Ä
        frame, coords = tracker.process_frame(draw_point=True)  # –í–∫–ª—é—á–∞–µ–º —Ç–æ—á–∫—É –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –Ω–∞ –∫–∞–º–µ—Ä–µ
        if frame is not None:
            # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –∫–∞–¥—Ä OpenCV (BGR) –≤ RGB –∏ –∑–∞—Ç–µ–º –≤ —Ç–µ–∫—Å—Ç—É—Ä—É Pygame
            frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            frame_surface = pygame.surfarray.make_surface(frame_rgb.swapaxes(0, 1))
            # –ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º –∫–∞–¥—Ä –¥–æ —Ä–∞–∑–º–µ—Ä–∞ –æ–∫–Ω–∞ –∫–∞–º–µ—Ä—ã (320x240)
            frame_surface = pygame.transform.scale(frame_surface, (320, 240))
        else:
            frame_surface = None

        if coords:
            x, y = coords
            # –ü–µ—Ä–µ–≤–æ–¥–∏–º –Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤ –ø–æ–∑–∏—Ü–∏—é —Ä–∞–∫–µ—Ç–∫–∏
            paddle_pos[0] = int(x * WIDTH - 70)  # –°–º–µ—â–µ–Ω–∏–µ –Ω–∞ –ø–æ–ª–æ–≤–∏–Ω—É —à–∏—Ä–∏–Ω—ã —Ä–∞–∫–µ—Ç–∫–∏
            paddle_pos[1] = int(y * HEIGHT - 70)
            if (paddle_pos[1] < 350) or (paddle_pos[1] > 650) or (paddle_pos[0] < 100) or (paddle_pos[0] > 1000):
                paddle_image.set_alpha(120)
            else:
                paddle_image.set_alpha(255)
            # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–≤–∏–∂–µ–Ω–∏–µ —Ä–∞–∫–µ—Ç–∫–∏ –ø–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏
            paddle_pos[0] = max(0, min(paddle_pos[0], WIDTH - 140))

        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ñ–∏–∑–∏–∫–∏ –º—è—á–∞
        ball_pos[0] += ball_velocity[0]
        ball_pos[1] += ball_velocity[1]

        # –£–º–µ–Ω—å—à–∞–µ–º —Ç–∞–π–º–µ—Ä –∫—É–ª–¥–∞—É–Ω–∞
        if paddle_collision_cooldown > 0:
            paddle_collision_cooldown -= 1

        # –û—Ç—Å–∫–æ–∫ –æ—Ç –≤–µ—Ä—Ö–Ω–µ–π –≥—Ä–∞–Ω–∏—Ü—ã (—Å—Ç–µ–Ω–∫–∞)
        if ball_pos[1] <= table_top_y:
            if abs(ball_velocity[1]) < 3:  # –ï—Å–ª–∏ —Å–∫–æ—Ä–æ—Å—Ç—å —Å–ª–∏—à–∫–æ–º –º–∞–ª–∞
                ball_velocity[1] = 8  # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –¥–æ—Å—Ç–∞—Ç–æ—á–Ω—É—é —Å–∫–æ—Ä–æ—Å—Ç—å
            else:
                ball_velocity[1] = -ball_velocity[1] * 0.95  # –ú–µ–Ω—å—à–µ–µ –∑–∞—Ç—É—Ö–∞–Ω–∏–µ
                
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ "–∑–∞–ª–∏–ø–∞–Ω–∏–µ" —É —Å—Ç–µ–Ω–∫–∏
            if abs(ball_pos[1] - table_top_y) < 5 and abs(ball_velocity[1]) < 1:
                ball_velocity[1] = 5  # –î–∞—ë–º –Ω–µ–±–æ–ª—å—à–æ–π —Ç–æ–ª—á–æ–∫ –≤–Ω–∏–∑

        # –ü—Ä–æ–ø–∞–¥–∞–Ω–∏–µ –º—è—á–∞ –∑–∞ –Ω–∏–∂–Ω—é—é –≥—Ä–∞–Ω–∏—Ü—É
        if ball_pos[1] >= table_bottom_y:
            opponent_score += 1
            ball_pos = [WIDTH // 2, HEIGHT // 3]  # –°–±—Ä–æ—Å –ø–æ–∑–∏—Ü–∏–∏
            reset_angle = random.uniform(MIN_BALL_ANGLE, MAX_BALL_ANGLE)
            speed = random.uniform(6, 8)  # –°–ª—É—á–∞–π–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ 6-8
            ball_velocity = [
                speed * math.cos(reset_angle) * random.choice([-1, 1]),  # –°–ª—É—á–∞–π–Ω–æ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏
                speed * math.sin(reset_angle)  # –í—Å–µ–≥–¥–∞ –≤–≤–µ—Ä—Ö (–∫ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫—É)
            ]
            random.seed(time.time() + random.random())
            
        # –°—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ —Å —Ä–∞–∫–µ—Ç–∫–æ–π
        paddle_rect = pygame.Rect(paddle_pos[0], paddle_pos[1], 140, 140)
        collision_rect = paddle_rect.inflate(-paddle_rect.width // 2, -paddle_rect.height // 2)  # –°—É–∂–∞–µ–º –∑–æ–Ω—É
        ball_rect = pygame.Rect(ball_pos[0] - 12, ball_pos[1] - 12, 24, 24)
        if collision_rect.colliderect(ball_rect) and paddle_collision_cooldown == 0:
            relative_x = (ball_pos[0] - (paddle_pos[0] + 70)) / 70
            ball_velocity[0] = relative_x * 25
            ball_velocity[1] = -abs(ball_velocity[1]) * 1.4  # –£—Å–∫–æ—Ä–µ–Ω–∏–µ –ø—Ä–∏ —É–¥–∞—Ä–µ
            player_score += 1
            paddle_collision_cooldown = 20  # ~0.33 —Å–µ–∫ –ø—Ä–∏ 60 FPS

    # --- –†–µ–Ω–¥–µ—Ä ---
    if game_state == MENU:
        draw_menu()
    else:
        draw_scene(frame_surface)

    pygame.display.set_caption(f"Table Tennis Wall - FPS: {clock.get_fps():.2f}")
    pygame.display.flip()
    clock.tick(60)

# --- –û—á–∏—Å—Ç–∫–∞ ---
tracker.stop_capture()
pygame.quit()
</file>

</files>
